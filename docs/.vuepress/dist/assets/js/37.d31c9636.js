(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{415:function(v,_,t){"use strict";t.r(_);var s=t(23),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"深拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝"}},[v._v("#")]),v._v(" 深拷贝")]),v._v(" "),t("ul",[t("li",[v._v("深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。拷贝前后两个对象互不影响。")])]),v._v(" "),t("p",[v._v("实现深拷贝的方法：")]),v._v(" "),t("p",[v._v("1、JSON.parse(JSON.stringify(object))")]),v._v(" "),t("p",[v._v("缺点：")]),v._v(" "),t("p",[v._v("会忽略undefined")]),v._v(" "),t("p",[v._v("会忽略symbol")]),v._v(" "),t("p",[v._v("不能序列化函数")]),v._v(" "),t("p",[v._v("不能解决循环引用的对象")]),v._v(" "),t("p",[v._v("2、采用递归去拷贝所有层级属性\n3、lodash函数库实现深拷贝,lodash很热门的函数库，提供了 lodash.cloneDeep()实现深拷贝。Lodash.js")]),v._v(" "),t("h2",{attrs:{id:"浅拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝"}},[v._v("#")]),v._v(" 浅拷贝")]),v._v(" "),t("ul",[t("li",[v._v("简单来说可以理解为浅拷贝只解决了第一层的问题，拷贝第一层的基本类型值，以及第一层的引用类型地址。")])]),v._v(" "),t("p",[v._v("实现浅拷贝的方法：\n对象")]),v._v(" "),t("ul",[t("li",[v._v("1、Object.assign()")]),v._v(" "),t("li",[v._v("2、…(ES6扩展运算符)")])]),v._v(" "),t("p",[v._v("数组")]),v._v(" "),t("ul",[t("li",[v._v("1、Array.prototype.slice()")]),v._v(" "),t("li",[v._v("2、Array.prototype.concat()")]),v._v(" "),t("li",[v._v("3、Array.from()")]),v._v(" "),t("li",[v._v("4、…(ES6扩展运算符)")])])])}),[],!1,null,null,null);_.default=a.exports}}]);